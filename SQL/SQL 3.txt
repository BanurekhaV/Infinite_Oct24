use infinitedb

--group by in sub query
select empname,gender,salary
from tblemployee where salary > 
                           (select avg(salary) from tblemployee)

--having clause
select * from tblEmployee
--dept wise minimum salary having minimum salary > dept 1
select deptid, min(salary) from tblemployee
group by deptid
having min(salary) >
                    (select min(salary) from tblemployee where deptid=1)

--exists operator
--to check if employee have a reporting manager or not
select empno, job, ename, deptno from employee tout
      where exists(select 'x' from employee where empid=tout.mgrid)
--or
select empno, job, ename, deptno from employee tout
    where empno in(select mgrid from employee where mgrid is not null)

-- find all departments that have employees
select deptnum, deptname from tblDepartment d
   where exists(select 'z' from tblEmployee where DeptId = d.DeptNum)
--using in
select deptnum, deptname from tblDepartment d
   where deptnum in(select DeptId from tblEmployee where DeptId = d.DeptNum)

-- find all departments that have no employees
select deptnum, deptname from tblDepartment d
   where not exists(select 'z' from tblEmployee where DeptId = d.DeptNum)

select deptnum, deptname from tblDepartment d
   where deptnum not in(select DeptId from tblEmployee where DeptId = d.DeptNum)

   ---inner query not returning any values leads to outer query also not having any data
   select ename, job from employee where job = (select job from employee where
                          ename='AAA')

-- find all employees who are not salesman and whose salary is less than
--any of the employee who is a salesman (1250,1500,1600)
 select empno,ename,job,salary
 from employee where salary <any 
	                      (select salary from employee where job ='salesman')
				and job <>'salesman'

--select 2nd highest problems solved using corelated subqueries
select empname, salary from tblEmployee
order by salary desc

update tblemployee set salary =5500 where empname like 'Bhanu%'

select e1.empname,e1.salary from tblemployee e1
where 2 =(select count(salary) from tblemployee e2 where e2.salary >=e1.Salary)

--In some cases corelated query can be replaced with inner join for faster performance

--eg 1. Find all employees whose salary is > than the average 
-- salary of that department

--with corelated sub query
select e1.empid,e1.empname, e1.deptid,e1.salary from tblemployee e1
where salary > (select avg(salary) from tblemployee e2 where e2.DeptId = e1.DeptId)
                --5166  bhanuprakash
				--5200  chiramya, hareesh

--with inner join
select e1.empid, e1.empname,e1.salary, e1.deptid from tblemployee e1
 inner join (select deptid, avg(salary) as avgsal from tblemployee group by deptid) as e2 on
                e1.deptid=e2.deptid where e1.salary > e2.avgsal


--corelated sub query for updation

--eg 2. update salary for all employees, whose salary is minimum in that dept
update tblemployee set salary = salary + 100
 from tblemployee t1 where salary <=
                                (select min(t2.salary) from tblemployee t2 where t2.deptid = t1.deptid)

select * from tblemployee

--bulk copy
select * from tbldummy

insert into tbldummy values(1,'A'),(2,'B'),(3,'C')

create table dummy2(did int, ddata varchar(20))

--when the source and destination objects have the same structure, and we need all data
insert into dummy2 select * from tbldummy


--if source table or destination has more attributes then we can be specific both in insert and select commands

alter table tbldummy add city varchar(20)

update tbldummy set city ='Noida'

insert into dummy2(did,ddata) select did,dname from tbldummy

select * from dummy2

--identity column : are like Primary key which can help in identifying a unique tuple/row
-- it is an autogenerated number /sequence  for that column
-- it is of integer type
-- it stops data insertion into the column
-- can be applied to any integer type

drop table dummy2

create table dummy2(did int identity(2,2), ddata varchar(20))
sp_help dummy2

insert into dummy2 values('CSharp'),('ASP.Net')
delete from dummy2 where did=8

--oracle
create sequence dbo.myseq
increment by 1
start with 5

drop sequence dbo.myseq

create table test(id int, title varchar(10))

insert into test values(Next Value for dbo.myseq, 'Jenkins')

select * from test

sp_help test



--hard delete
delete from tbldepartment where deptnum=1
--soft delete
update tbldepartment set Remarks ='Non-Operational' where deptnum=1

--case
create table casetable(cid int, cname varchar(20))

insert into casetable values(5,'White'),(3,'Blue'),(2,'Green'),(4,'Red')

--simple case without else
select cid,cname,
 case cname
    when 'Red' then 'Danger'
	when 'Blue' then 'Primary'
	when 'Green' then 'Success'
  end as 'Color Remarks'
 from casetable

 --simple case with else
select cid,cname,
 case cname
    when 'Red' then 'Danger'
	when 'Blue' then 'Primary'
	when 'Green' then 'Success'
	else 'No Remarks'
 end as 'Color Remarks'
 from casetable

 --searched case with else
 select cid,cname,
 case
   when cname ='Red' then 'Danger'
   when cname = 'Blue' then 'Primary'
   when cname = 'Green' then 'Success'
   else 'Incorrect Color'
 end as ColorStatus
 from casetable

 --nested case :
 declare @totsales int    -- decl a variable of a type
 set @totsales=230  -- assigning values to the variable
 select case
    when @totsales >=500 then 'Bumper Sales'
	when @totsales <500 then
	   case 
	      when @totsales between 100 and 200 then 'Poor sales'
		  when @totsales between 201 and 300 then 'Ok Sales'
		  when @totsales between 301 and 400 then 'Good Sales'
		  when @totsales between 401 and 500 then 'Very Good Sales'
		  else 'No Sales'
		end
	end as SalesDetails

--nested case inside if else
declare @sales int
set @sales=245
select @sales as 'Total Sales'

print 'The Total Sales made is ' + ' ' + cast(@sales as varchar(5))
if @sales > 500
  select 'Bumper Sales'
else
 begin
  select case
    when @sales between 100 and 200 then 'Poor sales'
	when @sales between 201 and 300 then 'Ok Sales'
	when @sales between 301 and 400 then 'Good Sales'
	else 'No Sales'
   end 'Sales Status'
end


--Tsql
--1.
begin
declare @v1 int=50, @v2 int =100
declare @sum int = @v1
--set @sum = @v1
print @sum
if(@v1 > @v2)
  print 'v1 is greater ' 
else
print 'v2 is greater'
end

--eg 2. using tsql increase the salary of all employees by rs 100/- who are earning less than emp 100

begin
declare @sal float
declare @name varchar(30)
select @name=empname, @sal=salary from tblemployee where empid=100 -- 5100

if(@sal <=5000)
 begin
   set @sal =@sal+100
   print 'the revised salary is ' + cast(@sal as varchar(5))
 end
 else
  begin
    print 'Salary is Ok'
  end
end

--while
declare @ctr int =1
while @ctr <=5
 begin
   print @ctr
   set @ctr =@ctr+1
  end

  --while with break
  declare @ctr1 int =0
while @ctr1 <=5
 begin
   set @ctr1 =@ctr1+1
   if @ctr1=4
   break
   print @ctr1
  end

  --while with continue
    declare @ctr2 int =0
while @ctr2 <=5
 begin
   set @ctr2 =@ctr2+1
   if @ctr2=4
  continue
   print @ctr2
  end
  end


--updating thru while loop

declare @CursorTestID INT 

select @CursorTestID = min(empid) from tblemployee
print @cursorTestID
DECLARE @RowCnt BIGINT = 0
declare @salary float, @rsal float
-- Get a count of total rows to process, with a SELECT COUNT statement
SELECT @RowCnt = max(empid) from tblemployee
select @salary = salary from tblemployee where empid=@cursorTestID  -- 5100
  
WHILE @CursorTestID <= @RowCnt
BEGIN
    select @rsal=salary from tblemployee where empid=@CursorTestID
   if(@rsal<@salary)
     begin
   UPDATE tblemployee
   SET salary = @rsal + 100
   --set @rsal=@rsal+100
   --print @rsal
   WHERE empid = @CursorTestID
   end
	else
	 begin
	   print 'Salary is Fine'
     end
  SET @CursorTestID = @CursorTestID + 1  
END


select * from tblemployee

