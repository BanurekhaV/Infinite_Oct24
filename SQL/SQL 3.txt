use infinitedb

--group by in sub query
select empname,gender,salary
from tblemployee where salary > 
                           (select avg(salary) from tblemployee)

--having clause
select * from tblEmployee
--dept wise minimum salary having minimum salary > dept 1
select deptid, min(salary) from tblemployee
group by deptid
having min(salary) >
                    (select min(salary) from tblemployee where deptid=1)

--exists operator
--to check if employee have a reporting manager or not
select empno, job, ename, deptno from employee tout
      where exists(select 'x' from employee where empid=tout.mgrid)
--or
select empno, job, ename, deptno from employee tout
    where empno in(select mgrid from employee where mgrid is not null)

-- find all departments that have employees
select deptnum, deptname from tblDepartment d
   where exists(select 'z' from tblEmployee where DeptId = d.DeptNum)
--using in
select deptnum, deptname from tblDepartment d
   where deptnum in(select DeptId from tblEmployee where DeptId = d.DeptNum)

-- find all departments that have no employees
select deptnum, deptname from tblDepartment d
   where not exists(select 'z' from tblEmployee where DeptId = d.DeptNum)

select deptnum, deptname from tblDepartment d
   where deptnum not in(select DeptId from tblEmployee where DeptId = d.DeptNum)

   ---inner query not returning any values leads to outer query also not having any data
   select ename, job from employee where job = (select job from employee where
                          ename='AAA')

-- find all employees who are not salesman and whose salary is less than
--any of the employee who is a salesman (1250,1500,1600)
 select empno,ename,job,salary
 from employee where salary <any 
	                      (select salary from employee where job ='salesman')
				and job <>'salesman'

--select 2nd highest problems solved using corelated subqueries
select empname, salary from tblEmployee
order by salary desc

update tblemployee set salary =5500 where empname like 'Bhanu%'

select e1.empname,e1.salary from tblemployee e1
where 2 =(select count(salary) from tblemployee e2 where e2.salary >=e1.Salary)

--In some cases corelated query can be replaced with inner join for faster performance

--eg 1. Find all employees whose salary is > than the average 
-- salary of that department

--with corelated sub query
select e1.empid,e1.empname, e1.deptid,e1.salary from tblemployee e1
where salary > (select avg(salary) from tblemployee e2 where e2.DeptId = e1.DeptId)
                --5166  bhanuprakash
				--5200  chiramya, hareesh

--with inner join
select e1.empid, e1.empname,e1.salary, e1.deptid from tblemployee e1
 inner join (select deptid, avg(salary) as avgsal from tblemployee group by deptid) as e2 on
                e1.deptid=e2.deptid where e1.salary > e2.avgsal


--corelated sub query for updation

--eg 2. update salary for all employees, whose salary is minimum in that dept
update tblemployee set salary = salary + 100
 from tblemployee t1 where salary <=
                                (select min(t2.salary) from tblemployee t2 where t2.deptid = t1.deptid)

select * from tblemployee

--bulk copy
select * from tbldummy

insert into tbldummy values(1,'A'),(2,'B'),(3,'C')

create table dummy2(did int, ddata varchar(20))

--when the source and destination objects have the same structure, and we need all data
insert into dummy2 select * from tbldummy


--if source table or destination has more attributes then we can be specific both in insert and select commands

alter table tbldummy add city varchar(20)

update tbldummy set city ='Noida'

insert into dummy2(did,ddata) select did,dname from tbldummy

select * from dummy2

--identity column : are like Primary key which can help in identifying a unique tuple/row
-- it is an autogenerated number /sequence  for that column
-- it is of integer type
-- it stops data insertion into the column
-- can be applied to any integer type

drop table dummy2

create table dummy2(did int identity(2,2), ddata varchar(20))
sp_help dummy2

insert into dummy2 values('CSharp'),('ASP.Net')
delete from dummy2 where did=8

--oracle
create sequence dbo.myseq
increment by 1
start with 5

drop sequence dbo.myseq

create table test(id int, title varchar(10))

insert into test values(Next Value for dbo.myseq, 'Jenkins')

select * from test

sp_help test



--hard delete
delete from tbldepartment where deptnum=1
--soft delete
update tbldepartment set Remarks ='Non-Operational' where deptnum=1

--case
create table casetable(cid int, cname varchar(20))

insert into casetable values(5,'White'),(3,'Blue'),(2,'Green'),(4,'Red')

--simple case without else
select cid,cname,
 case cname
    when 'Red' then 'Danger'
	when 'Blue' then 'Primary'
	when 'Green' then 'Success'
  end as 'Color Remarks'
 from casetable

 --simple case with else
select cid,cname,
 case cname
    when 'Red' then 'Danger'
	when 'Blue' then 'Primary'
	when 'Green' then 'Success'
	else 'No Remarks'
 end as 'Color Remarks'
 from casetable

 --searched case with else
 select cid,cname,
 case
   when cname ='Red' then 'Danger'
   when cname = 'Blue' then 'Primary'
   when cname = 'Green' then 'Success'
   else 'Incorrect Color'
 end as ColorStatus
 from casetable

 --nested case :
 declare @totsales int    -- decl a variable of a type
 set @totsales=230  -- assigning values to the variable
 select case
    when @totsales >=500 then 'Bumper Sales'
	when @totsales <500 then
	   case 
	      when @totsales between 100 and 200 then 'Poor sales'
		  when @totsales between 201 and 300 then 'Ok Sales'
		  when @totsales between 301 and 400 then 'Good Sales'
		  when @totsales between 401 and 500 then 'Very Good Sales'
		  else 'No Sales'
		end
	end as SalesDetails

--nested case inside if else
declare @sales int
set @sales=245
select @sales as 'Total Sales'

print 'The Total Sales made is ' + ' ' + cast(@sales as varchar(5))
if @sales > 500
  select 'Bumper Sales'
else
 begin
  select case
    when @sales between 100 and 200 then 'Poor sales'
	when @sales between 201 and 300 then 'Ok Sales'
	when @sales between 301 and 400 then 'Good Sales'
	else 'No Sales'
   end 'Sales Status'
end